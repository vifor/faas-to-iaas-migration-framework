# FaaS to NestJS Monolithic Migration Workplan

## 🏗️ **Current Architecture Analysis**

### **From FaaS (4 Lambda Functions) to Monolithic NestJS:**
- **Current**: 4 separate Lambda functions with API Gateway
- **Target**: Single NestJS application with modular architecture
- **Endpoints**: 21 total endpoints across 4 functional areas
- **Authentication**: API Key (admin) + JWT Bearer (store operations)
- **Authorization**: AWS Verified Permissions with Cedar policies
- **Database**: DynamoDB → Relational Database (PostgreSQL/MySQL)

## 📋 **Comprehensive Migration Workplan**

### **Phase 1: Architecture Analysis & Design (Week 1)**

#### 🔍 **Task 1: Analyze Current Architecture**
- **Current State Analysis:**
  - 6 admin endpoints for franchise management 
  - 6 admin endpoints for store management
  - 9 store endpoints with complex authorization
  - 2 authentication schemes (API Key + JWT)
  - DynamoDB with composite keys
  - AWS Verified Permissions integration

- **Dependencies to Replace:**
  - AWS Lambda → NestJS application server
  - API Gateway → Express.js routing
  - DynamoDB → PostgreSQL/MySQL with TypeORM
  - AWS Verified Permissions → Custom RBAC/ABAC
  - AWS Cognito JWT → Custom JWT with Passport.js

#### 🏛️ **Task 2: Design NestJS Architecture**
```
src/
├── auth/                 # Authentication & Authorization
│   ├── guards/          # Auth guards (API key, JWT)
│   ├── strategies/      # Passport strategies
│   └── decorators/      # Custom auth decorators
├── franchise/           # Franchise module
│   ├── controllers/     # Admin franchise endpoints
│   ├── services/        # Business logic
│   ├── entities/        # Database entities
│   └── dto/            # Data transfer objects
├── store/              # Store module
│   ├── controllers/    # Admin store endpoints  
│   ├── services/       # Business logic
│   ├── entities/       # Database entities
│   └── dto/           # Data transfer objects
├── pet/               # Pet module
│   ├── controllers/   # Store pet endpoints
│   ├── services/      # Business logic with authorization
│   ├── entities/      # Database entities
│   └── dto/          # Data transfer objects
├── order/            # Order module
│   ├── controllers/  # Store order endpoints
│   ├── services/     # Business logic with authorization
│   ├── entities/     # Database entities
│   └── dto/         # Data transfer objects
├── inventory/        # Inventory module
├── database/         # Database configuration
└── common/          # Shared utilities
```

### **Phase 2: Project Setup & Foundation (Week 2)**

#### ⚡ **Task 3: Setup NestJS Project**
```bash
# Core dependencies
npm install @nestjs/core @nestjs/common @nestjs/platform-express
npm install @nestjs/typeorm typeorm postgresql
npm install @nestjs/passport passport passport-jwt passport-local
npm install @nestjs/swagger swagger-ui-express
npm install class-validator class-transformer
npm install bcrypt jsonwebtoken

# Development dependencies  
npm install --save-dev @types/node typescript ts-node
npm install --save-dev jest @nestjs/testing
```

#### 🔐 **Task 4: Implement Auth System**
- **API Key Authentication** (for `/admin/*`)
  ```typescript
  @Injectable()
  export class ApiKeyGuard implements CanActivate {
    canActivate(context: ExecutionContext): boolean {
      const request = context.switchToHttp().getRequest();
      const apiKey = request.headers['x-api-key'];
      return this.validateApiKey(apiKey);
    }
  }
  ```

- **JWT Authentication** (for `/store/*`)
  ```typescript
  @Injectable()
  export class JwtAuthGuard extends AuthGuard('jwt') {
    canActivate(context: ExecutionContext) {
      return super.canActivate(context);
    }
  }
  ```

- **Custom Authorization Service** (replacing AWS Verified Permissions)
  ```typescript
  @Injectable()
  export class AuthorizationService {
    async checkPermission(user: User, action: string, resource: any): Promise<boolean> {
      // Implement Cedar-like policy evaluation
      return this.evaluatePolicies(user, action, resource);
    }
  }
  ```

### **Phase 3: Module Migration (Weeks 3-6)**

#### 🏢 **Task 5: Migrate Franchise Module**
- **Controllers**: 6 endpoints
  ```typescript
  @Controller('admin/franchise')
  @UseGuards(ApiKeyGuard)
  export class FranchiseController {
    @Get() listFranchises()
    @Post() createFranchise()
    @Put() updateFranchise()
    @Get(':id') getFranchisesByID()
    @Get('object/:id') getFranchise()
    @Delete('object/:id') deleteFranchise()
  }
  ```

- **Database Migration**: DynamoDB → PostgreSQL
  ```typescript
  @Entity()
  export class Franchise {
    @PrimaryColumn()
    id: string;
    
    @Column()
    name: string;
    
    @Column({ nullable: true })
    location: string;
    
    @OneToMany(() => Store, store => store.franchise)
    stores: Store[];
    
    @CreateDateColumn()
    createdAt: Date;
    
    @UpdateDateColumn()
    updatedAt: Date;
  }
  ```

#### 🏪 **Task 6: Migrate Store Module**
- **Controllers**: 6 endpoints with composite key handling
- **Complex Key Migration**: DynamoDB composite key (id, value) → PostgreSQL compound primary key
- **Business Logic**: Store-franchise relationships

#### 🐕 **Task 7: Migrate Pet Module**
- **Authorization Integration**: Store-level permissions
- **Controllers**: 4 endpoints with authorization checks
- **Service Layer**: Business logic with permission validation
  ```typescript
  @Injectable()
  export class PetService {
    async createPet(storeId: string, petData: CreatePetDto, user: User) {
      // Check authorization
      const canCreate = await this.authService.checkPermission(
        user, 'AddPet', { storeId }
      );
      if (!canCreate) throw new ForbiddenException();
      
      // Business logic
      return this.petRepository.save(petData);
    }
  }
  ```

#### 📋 **Task 8: Migrate Order Module**
- **Controllers**: 4 endpoints with complex authorization
- **Order Management**: Status tracking, cancellation logic
- **User-based Authorization**: Order ownership validation

### **Phase 4: Data & Infrastructure (Week 7)**

#### 🗄️ **Task 9: Database Migration**
- **Schema Design**: Convert DynamoDB structure to relational
  ```sql
  -- Franchise table
  CREATE TABLE franchises (
    id VARCHAR PRIMARY KEY,
    name VARCHAR NOT NULL,
    location VARCHAR,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
  );
  
  -- Store table (handling composite key)
  CREATE TABLE stores (
    id VARCHAR,
    value VARCHAR,
    name VARCHAR,
    address VARCHAR,
    franchise_id VARCHAR REFERENCES franchises(id),
    PRIMARY KEY (id, value),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
  );
  ```

- **Data Migration Scripts**: DynamoDB → PostgreSQL
- **Connection Pool Configuration**: Production-ready database setup

### **Phase 5: Testing & Quality Assurance (Week 8)**

#### 🧪 **Task 10: Testing Implementation**
- **Unit Tests**: Service layer testing
  ```typescript
  describe('FranchiseService', () => {
    it('should create franchise with valid data', async () => {
      const franchiseData = { id: 'test-001', name: 'Test Franchise' };
      const result = await service.create(franchiseData);
      expect(result.id).toBe('test-001');
    });
  });
  ```

- **Integration Tests**: Controller and database testing
- **E2E Tests**: Full API endpoint testing
- **Authorization Tests**: Permission and security validation

### **Phase 6: Optimization & Deployment (Week 9)**

#### ⚡ **Task 11: Optimization & Deployment**
- **Performance Optimization**:
  - Database query optimization
  - Caching layer implementation
  - Rate limiting and throttling
  
- **Production Configuration**:
  ```typescript
  // Production environment
  export const config = {
    database: {
      type: 'postgres',
      host: process.env.DB_HOST,
      port: +process.env.DB_PORT,
      username: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      ssl: true,
      poolSize: 20,
    },
    auth: {
      jwtSecret: process.env.JWT_SECRET,
      apiKey: process.env.API_KEY,
    }
  };
  ```

- **Docker Configuration**:
  ```dockerfile
  FROM node:18-alpine
  WORKDIR /app
  COPY package*.json ./
  RUN npm ci --only=production
  COPY . .
  RUN npm run build
  CMD ["npm", "run", "start:prod"]
  ```

#### 📚 **Task 12: Documentation & Scripts**
- **API Documentation**: Swagger/OpenAPI integration
- **Migration Scripts**: Automated deployment procedures
- **Monitoring Setup**: Health checks, logging, metrics
- **Security Hardening**: Rate limiting, input validation, CORS

## 🎯 **Key Migration Challenges & Solutions**

### **1. Authentication & Authorization**
- **Challenge**: Replace AWS Verified Permissions
- **Solution**: Custom RBAC/ABAC with policy engine
- **Implementation**: User roles, permissions matrix, resource-based access

### **2. Database Transformation**
- **Challenge**: DynamoDB NoSQL → PostgreSQL relational
- **Solution**: Careful schema design maintaining data relationships
- **Key Changes**: Composite keys → compound primary keys

### **3. Performance Considerations**
- **Challenge**: Single application vs distributed Lambda functions
- **Solution**: Horizontal scaling, load balancing, caching
- **Monitoring**: Application performance monitoring (APM)

### **4. Deployment Strategy**
- **Challenge**: Seamless migration without downtime
- **Solution**: Blue-green deployment with API versioning
- **Rollback Plan**: Database backup and application rollback procedures

## 📊 **Expected Outcomes**

### **Benefits:**
- ✅ **Simplified Architecture**: Single codebase vs 4 Lambda functions
- ✅ **Cost Optimization**: Reduced AWS Lambda invocation costs
- ✅ **Easier Development**: Unified development environment
- ✅ **Better Testing**: Integrated testing across modules
- ✅ **Improved Monitoring**: Single application monitoring

### **Considerations:**
- 🔄 **Scaling Strategy**: Horizontal scaling vs auto-scaling Lambda
- 💾 **State Management**: Session handling in monolithic app
- 🔒 **Security**: Centralized security vs distributed security
- 📈 **Performance**: Single point of failure vs distributed resilience

## 🚀 **Implementation Timeline**

| Week | Phase | Focus Area | Deliverables |
|------|-------|------------|--------------|
| 1 | Architecture Analysis | Current state analysis, NestJS design | Architecture documentation, migration plan |
| 2 | Project Setup | NestJS project initialization, auth system | Working NestJS skeleton with authentication |
| 3 | Franchise Migration | Admin franchise endpoints | Franchise module with all 6 endpoints |
| 4 | Store Migration | Admin store endpoints | Store module with composite key handling |
| 5 | Pet Migration | Store pet endpoints with authorization | Pet module with permission checks |
| 6 | Order Migration | Store order endpoints with authorization | Order module with complex authorization |
| 7 | Database Migration | Schema design, data migration | PostgreSQL schema, migration scripts |
| 8 | Testing | Unit, integration, E2E tests | Comprehensive test suite |
| 9 | Deployment | Production setup, optimization | Production-ready application |

## 📝 **Migration Checklist**

### **Pre-Migration:**
- [ ] Analyze all 21 endpoints from OpenAPI specification
- [ ] Identify authentication and authorization requirements
- [ ] Map DynamoDB tables to PostgreSQL schema
- [ ] Document current business logic and rules

### **During Migration:**
- [ ] Set up NestJS project with proper structure
- [ ] Implement authentication guards (API Key + JWT)
- [ ] Create database entities with TypeORM
- [ ] Migrate each module with proper testing
- [ ] Implement authorization service replacing AWS Verified Permissions
- [ ] Set up comprehensive logging and monitoring

### **Post-Migration:**
- [ ] Performance testing and optimization
- [ ] Security audit and hardening
- [ ] Documentation updates
- [ ] Deployment automation
- [ ] Monitoring and alerting setup
- [ ] Rollback procedures verification

This workplan provides a systematic approach to migrate from FaaS to a monolithic NestJS application while maintaining all existing functionality and improving the overall architecture! 🚀
